\documentclass{article}

\begin{document}

\title{A4 Manual}
\author{Daniel Lemmond\\
20302247}

\maketitle

\section{Implementation Decisions}

\subsection{Hierarchy Flattening}

I decided to flatten my hierarchy, as was suggested in the assignment specification. My reasoning was that there really is no reason why transformations have to specified hierarchally after the user is done with them. My implementation completely avoids modifying the hierarchy data structure, as this causes problems in the case of instancing or multiple calls to the LUA interface {\tt render} function.

In {\tt a4\_render}, I immediately flatten the hierarchy by traversing it and accumulating transformations. I store every leaf node (ie, every Primitive) alongside its material and the flattened transformation in an instance of the {\tt FlatGeo} data structure defined in {\tt scene.hpp}. All of the leaf nodes are stored in a vector. Then for intersection computations I iterate through this vector rather than traversing a tree.

\subsection{Bounding Boxes}

I implemented bounding volumes for mesh primitives via axis-aligned bounding
boxes, since they are slightly easier to compute than bounding spheres. In
particular, the vertex coordinates for each bounding box can be found by taking
the extreme points along each axis. I test for intersection with these bounding
boxes by using the same algorithm I use for mesh intersection; see that section
for more.

\subsection{Mesh Intersection}

I test for mesh intersections by checking for intersections with each of the
polygons in the mesh. For polygon intersection, I use the algorithm from pp. 122-123 of the
course notes. This involves first determining the plane equation from three of
the vertices in the polygon. Once we have that, we can use our parametric ray
equation to solve for $t$ and thus find the intersection point with the plane.
With that, we can determine if the point is actually within the bounds of the
polygon by using a wrapping algorithm that checks whether it's on the same side
of every edge in the polygon.

\section{Extra Features}

\subsection{Adaptive Anti-Aliasing by Supersampling}

My special feature is adaptive anti-aliasing by supersampling. Here's how it
works. The user specifies a number $n$, which is related to the number of
samples made for problem pixels. We divide each unit on the projection screen
into an $n$ by $n$ grid. The grid is offset from the actual projection screen grid so that the
first point in our $n$ by $n$ grid is actually $\frac{1}{2n}$ units away from
the projection screen grid boundary.

Before doing anything else, we perform lighting calculations for the four corner
points on the $n$ by $n$ grid. Using the resulting values, we can get an idea of
whether the current unit contains a discontinuity (and thus is a candidate for
anti-aliasing). To this aim, I compute the ``distance" between each pair of
colours; that is, I treat them like vectors, subtract one from the other, and
determine the length of the resulting colour. The higher the distance, the
higher the discontinuity for this element. If the maximum distance between any
two of the four sample points that I've already computed is larger than a
hard-coded or user-specified threshold, the element is a candidate for
anti-aliasing. Otherwise, we use the average value of the four colours we've
already sampled for the pixel's colour.

When a pixel is targeted in this way for anti-aliasing, we sample each of the
other $n^2 - 4$ points in the $n$ by $n$ grid for that pixel and average all of
the samples we've made in order to determine the pixel's value. This is
expensive; thus the need to avoid doing it when there are no discontinuities.

\subsection{Multhreading}

I took advantage by the ``embarassing parallelism" of ray tracing by making my
ray tracer multithreaded. In particular, I spawn a number of threads, each of
which repeatedly queries a threadsafe queue data structure. This structure doles
out rows of the image being rendered, and each thread, upon receiving a row,
renders it before asking for another. The result is a significant speedup.

\section{Command-Line Arguments}

\begin{itemize}

  \item {\tt --enable-draw-bv}: draws bounding volumes for polygonal meshes rather
    than the meshes themselves.

  \item {\tt --enable-draw-aa}: highlights pixels which are selected for
    supersampling by colouring them red.

  \item {\tt --aa-grid N}: has the ray tracer perform anti-aliasing via an NxN
    grid. Increasing N should make discontinuities look smoother while
    increasing runtime. Setting N to $1$ effectively disables anti-aliasing. The
    default value is $3$.

  \item {\tt --aa-threshold}: sets the anti-aliasing threshold. Higher values
    will cause more pixels to be selected for anti-aliasing. The (relatively
    arbitrary, but functional) default value is $0.5$.

  \item {\tt --threads N}: has the ray tracer use N threads. Use as many as you
    can; the speedup is essentially linear. The default value is $4$.

\end{itemize}

\end{document}
